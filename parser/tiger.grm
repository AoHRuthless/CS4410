structure A = Absyn

%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | UMINUS
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

(* TODO fix nonterm list *)
%nonterm program of A.exp
       | expr of A.exp
       | binary_op
       | expr_seq of A.exp list
       | expr_list of A.exp list
       | field_list
       | lvalue
       | type_id
       | decl_seq of A.dec list
       | decl of A.dec
       | type_decl of A.TypeDec
       | type_val
       | type_fields
       | type_field
       | var_decl of A.VarDec
       | func_decl of A.FunctionDec

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%nonassoc ASSIGN THEN
%nonassoc ELSE
%left OR
%left AND
%nonassoc EQ NEQ GT LT GE LE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

program: expr    ((*expr*))

expr: STRING                              ((*A.Stringexpr(STRING, STRINGleft)*))
    | INT                                 ((*A.Intexpr(INT)*))
    | NIL                                 ((*A.Nilexpr*))
    | lvalue                              ()
    | MINUS %prec UMINUS                  ((*A.Opexpr{left = A.Intexpr(0), oper = A.MinusOp, right =, pos = MINUSleft}*))
    | expr binary_op expr                 ((*binary_expr*))
    | lvalue ASSIGN expr                  ()
    | ID LPAREN expr_list RPAREN          ()
    | LPAREN expr_seq RPAREN              ((*A.Seqexpr(rev(expr_seq))*))
    | type_id LBRACE field_list RBRACE    ()
    | type_id LBRACK expr RBRACK OF expr  ()
    | IF expr THEN expr                   ((*A.Ifexpr({test=exp1, then'=exp2, else'=NONE, pos=IFleft})*))
    | IF expr THEN expr ELSE expr         ((*A.Ifexpr({test=exp1, then'=exp2, else'=SOME exp3, pos=IFleft})*))
    | WHILE expr DO expr                  ((*A.Whileexpr{test = exp1, body = exp2, pos = WHILEleft}*)) 
    | FOR ID ASSIGN expr TO expr DO expr  ((*A.Forexpr{var = Symbol.symbol(ID), escape = ref true, lo = exp1, high = exp2, body = exp3, pos = FORleft}*))
    | BREAK                               ((*A.Breakexpr(BREAKleft)*))
    | LET decl_seq IN expr_seq END        ((*A.Letexpr{decs = rev(decl_seq), body = A.Seqexpr(rev(expr_seq)), pos = LETleft}*))

binary_op: PLUS     ((*A.Opexpr{left = exp1, oper = A.PlusOp, right = exp2, pos = exp1left}*))
         | MINUS    ((*A.Opexpr{left = exp1, oper = A.MinusOp, right = exp2, pos = exp1left}*))
         | TIMES    ((*A.Opexpr{left = exp1, oper = A.TimesOp, right = exp2, pos = exp1left}*))
         | DIVIDE   ((*A.Opexpr{left = exp1, oper = A.DivideOp, right = exp2, pos = exp1left}*))
         | EQ       ((*A.Opexpr{left = exp1, oper = A.EqOp, right = exp2, pos = exp1left}*))
         | NEQ      ((*A.Opexpr{left = exp1, oper = A.NeqOp, right = exp2, pos = exp1left}*))
         | LT       ((*A.Opexpr{left = exp1, oper = A.LtOp, right = exp2, pos = exp1left}*))
         | GT       ((*A.Opexpr{left = exp1, oper = A.GtOp, right = exp2, pos = exp1left}*))
         | GE       ((*A.Opexpr{left = exp1, oper = A.GeOp, right = exp2, pos = exp1left}*))
         | LE       ((*A.Opexpr{left = exp1, oper = A.LeOp, right = exp2, pos = exp1left}*))
         | AND      ((*A.Ifexpr{test = exp1, then='exp2, else' = SOME(A.Intexpr(0)), pos = exp1left}*))
         | OR       ((*A.Ifexpr{test = exp1, then'=A.Intexpr(1), else'=SOME exp2, pos=exp1left}*))

expr_seq: expr_seq SEMICOLON expr  ((*(expr, expleft)::expr_seq*))
        | expr                     ((*(expr, expleft)::nil*))
        |                          ()

expr_list: expr_list COMMA expr    ((*(expr, expleft)::expr_seq*))
         | expr                    ((*(expr, expleft)::nil*))
         |                         ()

field_list: field_list COMMA ID EQ expr     ()
          | ID EQ expr                      ()
          |                                 ()

lvalue: ID                                  ()
      | lvalue DOT ID                       ()
      | lvalue LBRACK expr RBRACK           ()

type_id: ID                                 ()

decl_seq: decl_seq decl  ((*decl::decl_seq*))
        | decl           ((*decl::nil*))

decl: type_decl     ()
    | var_decl      ()
    | func_decl     ()

type_decl: TYPE type_id EQ type_val ()

type_val: type_id                       ()
        | LBRACE type_fields RBRACE     ()
        | ARRAY OF type_id              ()

type_fields: type_field                       ()
           | type_fields COMMA type_field     ()
           |                                  ()

type_field: ID COMMA type_id     ()

var_decl: VAR ID ASSIGN expr                  ()
        | VAR ID COLON type_id ASSIGN expr    ()

func_decl: FUNCTION ID LPAREN type_fields RPAREN EQ expr                 ()
         | FUNCTION ID LPAREN type_fields RPAREN COLON type_id EQ expr   ()
