# CS4410
Compilers @ Northeastern University
Team: Anand Kumar (akumar) + David Reed (reedda)

See `README.md` under child folders for more granular information:

- `lexer/` -- Lexer information

- `parser/` -- Parser information (includes updated Lexer)

- `semant/` -- Initial semantic analysis (type-checking)

- `ir/` -- Complete semantic analysis (type-checking and frame analysis)

- `insn/` -- Instruction Selection

- `live/` -- Liveness Analysis

- `color/` -- Register allocation

## Integration

### Procedure

Following the textbook (chapter 12), we implemented Frame.string, a main routine, and completed
the implementations of procEntryExit2 and procEntryExit3. Then our focus was on testing (using
QtSpim as a SPIM software simulator) our factorial code. Our factorial assembler can be found in
`tests_custom/factorial.tig.s` (generated by the corresponding `tests_custom/factorial.tig` file).

### Points of Interest

- Our factorial assembler located in `tests_custom/factorial.tig.s`
- the extra instructions we pad around the body during prologue and epilogue in procEntryExit3. First, we
copy current FP to SP to get a new frame, then set new SP offset/allocate the frame, then store registers before the body. After the body, we load the registers back, deallocate the frame, move sp to fp then reset fp using link.
- Our main routine generates a new `.s` assembler listing for each file it compiles.

### Errors

As of submission, there are two notable errors in our code:

1. Unsaved return address register

Despite best efforts, the return address is not being saved and loaded
onto the stack frame. Code to do so should be within `ir/mipsframe.sml` under 
`procEntryExit1`, however the output does not seem to reflect this.

2. Incorrect argument register offsets

Similarly, when making a function call, the argument registers are, by the looks
of it, being saved as needed (`sw $a0, 4($fp)`), however they are not being loaded
on the other side of the function call.

### Testing

We tested by generating the assembly for the test files we have (in various `test` directories) using `Main.compile "path/to/test.tig"`. Then, using QtSpim or command-line (`brew install spim`) we would test the compiled .s file.

### Creating runnable assembly

Once you have `factorial.tig.s`, simply concat the included `runtime.s` to the beginning:

```
cat runtime.s >> factorial.tig.s
```

See top-level `factorial.tig.s` to see the output.

### Superceding Previous Assignments

Our assignment 7 submission was late, and we expect a 10% penalty on the original grade. Additionally, we didn't compute liveness correctly. We fixed this by rewriting our logic to build the CFG in order to compute liveness.
